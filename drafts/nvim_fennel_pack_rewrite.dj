---toml
title = "Packing Neovim with Fennel"
tags = ["Lua", "Fennel", "Neovim"]
---

![I've got lots of stuff to do but I ended up rewriting my Neovim config instead.](/images/new_config_meme.jpg)

> ... anyone can do any amount of work, provided it isn't the work he is supposed to be doing at that moment.
> ^ Robert Benchley, in Chips off the Old Benchley, 1949

My partner Veronica is amazing as she'll listen to my bullshit and random whims (or at least, pretend to).
That's a big benefit to having a blog: so I have an outlet for rambling about my weird projects and random fixations and spare Veronica's sanity a little.

I know that Veronica won't be impressed by another Neovim config rewrite (even when done in Lisp!) so I'll simply write a big blog post about it.

{% Cause if she has to hear about me rewriting my Neovim config _again_ and why this time it's a good idea because I did it in Lisp %}



{% My partner Veronica is great at many things and she'll listen to most of my bullshit. %}

{% The purpose of my blog is for me to be ab && %}

{% The reason I have a blog is to %}

{% One of the reasons I have a blog is as an outlet for my weird projects or things I happen to fixate on. %}

{% My partner Veronica---blessed with an ungodly amount of patience---just isn't %}

{% Veronica doesn't want to listen to me excitedly telling her about why [Fennel][] is nicer than Lua; how I spent a hundred lines of code (together with [a plugin][lze]) to replicate existing [lazy.nvim][] functionality; or ... %}

::: warn
This post will contain wild Lisp code and random Neovim references.
Please consult the [Fennel safety manual][] and your nearest [Neovim :help station][] for assistance.
:::

:table-of-content:

# The rewrite

I wanted to rewrite my Neovim configuration in [Fennel][] (a Lisp that compiles to Lua) and while doing so I wanted to migrate from [lazy.nvim][] to Neovim's new built-in package manager [vim.pack][].

This included bootstrapping [Fennel][] compilation for Neovim; replicating missing features from [lazy.nvim][] such as running build scripts and lazy loading; fixing breaking changes with some plugins; and trying out some new exciting plugins.

## Why Fennel?

* I haven't played around with a new programming language since forever
* [Fennel][] has some nice quality of life features I like such as destructuring, the pipe operator, and macros

## Why [vim.pack][]?

> I don't rewrite my config often. But when I do, I do it properly.
> ^ Ancient Neovim wisdom

I'm an expert procrastinator.

* Removal of a major dependency

  Folke recently had a vacation and his many plugins were left without activity for months.
  This made me realize that I should probably try to reduce the [buss factor][] of my setup---at least for the biggest dependencies, and what's bigger than the package manager itself?

* Fun to try out new things

# Structuring the config

If you've got a small configuration having it all inside a single `init.lua` is probably fine.
Somehow I've managed gather almost 6k lines of Lua code under `~/.config/nvim` so this isn't an option for me.

I first wanted to separate the configuration into `core`/`plugin` split, where non-plugin configuration happens in `core` and plugin configuration lives under `plugin`.
However, to support lazy loading with a single call to [vim.pack.add][] I decided to go back to letting the files under `plugin/` return plugin specs, like [lazy.nvim][] does for you.

With Fennel support under `fnl/` this is how my configuration is structured:

```
init.lua                ; Minimal bootstrap to load Fennel files
fnl                     ; All Fennel source in the `fnl/` folder
├── config
│   ├── init.fnl        ; Loaded by `init.lua` and loads the rest
│   ├── colorscheme.fnl
│   ├── keymaps.fnl
│   ├── lsp.fnl         ; Config may reference plugins
│   └── ...
├── macros.fnl          ; Custom Fennel macros goes here
└── plugins
    ├── init.fnl        ; Loads everything under `plugins/`
    ├── appearance.fnl
    ├── coding.fnl
    └── ...
lua                     ; Lua stuff is still loaded transparently
ftplugin
└── djot.lua            ; nvim-thyme doesn't load `ftplugin/`
```

It's not a perfect system as I'd ideally want the `plugins/` to only add packages while I would configure the plugins in `config/`.
But some plugins use lazy loading making it more convenient to do it together with the plugin spec.

# Bootstrapping Fennel

There are a handful of different plugins that allows you to easily write your Neovim config in Fennel.
I ended up choosing [nvim-thyme][] because it's fast (it hooks into `require` and only compiles on-demand) and [nvim-thyme][] allows you to mix Fennel and Lua source files.

::: tip
[nvim-thyme][] compiles Fennel sources to Lua files and adds them to Neovim's runtimepath.
This is how it allows you to seamlessly mix Fennel and Lua, where some parts may be written in Fennel and others in Lua.
On my machine they're located at `~/.cache/nvim/thyme/compile/lua/`.
:::

[nvim-thyme][] contains installation instructions for [lazy.nvim][] and it references a bootstrapping function to run `git` to manually clone packages.
But we're going to use [vim.pack][] and it makes it a bit cleaner:

{path="init.lua"}
```lua
vim.pack.add({
  -- Fennel environment and compiler.
  "https://github.com/aileot/nvim-thyme",
  "https://git.sr.ht/~technomancy/fennel",
  -- Gives us some pleasant fennel macros.
  "https://github.com/aileot/nvim-laurel",
  -- Enables lazy loading of plugins.
  "https://github.com/BirdeeHub/lze",
}, { confirm = false })
```

(I added [lze][] to my bootstrapping too as I'll use it later [when adding lazy loading support][], it was simpler having it in the boostrap.)

[nvim-thyme][] also instructs us to override `require()` calls (so it can compile on demand) and
to setup the cache path (where it'll store the compiled Lua files):

{path="init.lua"}
```lua
-- Override package loading so thyme can hook into `require` calls
-- and generate lua code if the required package is a fennel file.
table.insert(package.loaders, function(...)
  return require("thyme").loader(...)
end)

-- Setup the compile cache path that thyme requires.
local thyme_cache_prefix = vim.fn.stdpath("cache") .. "/thyme/compiled"
vim.opt.rtp:prepend(thyme_cache_prefix)
```

And now we're ready to write the rest of the config with Fennel!

{path="init.lua"}
```lua
-- Load the rest of the config with transparent fennel support.
require("config")
```

Now we can continue with Fennel `fnl/config.fnl` or `fnl/config/init.fnl`:

{path="fnl/config/init.fnl"}
```fennel
;; Load all plugins
(require :plugins)

;; Load the other config files
(require :config.colorscheme)
(require :config.keymaps)
(require :config.lsp)
;; etc...
```

::: note
Keep in mind that we don't have to stay with Fennel all the time.\
`(require :config.lsp)`{=fennel} can load either `fnl/config/lsp.fnl` or `lua/config/lsp.lua`.
:::

There's one last thing we should do to make the bootstrap complete: we should call `:ThymeCacheClear` when `nvim-laurel` or `nvim-thyme` changes.
The recommended way is to use the [PackChanged][] event, with something like this:

{path="fnl/config/init.fnl"}
```lua
vim.api.nvim_create_autocmd("PackChanged", {
  callback = function(event)
    local name = event.data.spec.name

    if name == "nvim-thyme" or name == "nvim-laurel" then
      require("thyme").setup()
      vim.cmd("ThymeCacheClear")
    end
  end,
  group = vim.api.nvim_create_augroup("init.lua", { clear = true }),
})
```

But if we for example force an update for `nvim-laurel` (by deleting it with [vim.pack.del][] and restart) we get this error:

```
Error in /home/tree/code/nvim-conf/init.lua..PackChanged Autocommands for "*":
Lua callback: /home/tree/code/nvim-conf/init.lua:12: module 'thyme' not found:
        no field package.preload['thyme']
        cache_loader: module 'thyme' not found
        cache_loader_lib: module 'thyme' not found
        no file './thyme.lua'
        ...
```

There is no order guarantee for the packages and so `PackChanged` for `nvim-laurel` may run before `thyme` has been loaded.
I worked around this with a variable that I check after `vim.pack.add`, which will guarantee that all packages have been added before we try to require a package:

{path="fnl/config/init.fnl" hl="1,8,23..29"}
```lua
local rebuild_thyme = false

vim.api.nvim_create_autocmd("PackChanged", {
  callback = function(event)
    local name = event.data.spec.name

    if name == "nvim-thyme" or name == "nvim-laurel" then
      rebuild_thyme = true
    end
  end,
  group = vim.api.nvim_create_augroup("init.lua", { clear = true }),
})

vim.pack.add(...)

table.insert(package.loaders, function(...)
  return require("thyme").loader(...)
end)

local thyme_cache_prefix = vim.fn.stdpath("cache") .. "/thyme/compiled"
vim.opt.rtp:prepend(thyme_cache_prefix)

require("thyme").setup()

-- Rebuild thyme cache after `vim.pack.add` to avoid dependency issues
-- and to make sure all packages are loaded.
if rebuild_thyme then
  vim.cmd("ThymeCacheClear")
end
```

::: note
[nvim-thyme][] recommends `require("thyme").setup()`{=lua} to be done in `VimEnter` for speed reasons but I haven't noticed any slowdown so I'll just keep it in `init.lua` for simplicity.
:::

# Building a convenient plugin management system

I wanted to migrate to [vim.pack][] but it's missing a few key features from [lazy.nvim][]:

* It can't automatically require all files under a directory.
* There's no lazy loading support.
* It can't run build scripts (such as `make` after install or update).

I could've given up and gone back to [lazy.nvim][] but that just wouldn't do.

## Source pack specs from files

What I want is to be able to create a file under `plugins/`, have it return a [vim.pack.Spec][] and have it automatically added. This is similar to the [structured plugins][] approach of [lazy.nvim][].

To build this I first list all files under `plugins/` like so:

{path="fnl/plugins/init.fnl"}
```fennel
;; List all files, with absolute paths.
(local paths (-> (vim.fn.stdpath "config")
                 (.. "/fnl/plugins/*")
                 (vim.fn.glob)
                 (vim.split "\n")))
```

This uses Fennel's [-> threading macro][], Fennel's version of the pipe operator.
It's one of my favorite features of Elixir and was stoked to discover that Fennel has it too.
(Fennel actually has even more power with the `->>`, `-?>`, and `-?>>` operators!)

Now we need to loop through and transform the paths to relative paths and evaluate the files to get our specs.
I'm using [accumulate][] instead of [collect][] as we'll soon extend it:

[collect]: https://fennel-lang.org/reference#icollect-collect-table-comprehension-macros
[accumulate]: https://fennel-lang.org/reference#accumulate-iterator-accumulation

{path="fnl/plugins/init.fnl"}
```fennel
;; Make the paths relative to plugins and remove extension, e.g. "plugins/snacks"
;; and require those packages to get our pack specs.
(local specs (accumulate [acc [] _ abs_path (ipairs paths)]
               (do
                 (local path (string.match abs_path "(plugins/[^./]+)%.fnl$"))
                 (if (and path (not= path "plugins/init"))
                     (do
                       (local mod_res (require path))
                       (table.insert acc mod_res))
                       acc)
                     acc))))
```

Now we can populate `specs` from files under `plugins/`, for example like this that returns a single spec:

{path="fnl/plugins/misc.fnl"}
```fennel
{:src "https://github.com/romainl/vim-cool"}
```

::: note
Fennel's table syntax felt a bit weird for me at first.
`:src`{=fennel} is the same as `"src"`{=fennel} and the above code translates to this Lua:

```lua
return { src = "https://github.com/romainl/vim-cool" }
```
:::

But I also want to be able to return multiple specs, such as this:

{path="fnl/plugins/deps.fnl"}
```fennel
[{:src "https://github.com/nvim-lua/popup.nvim"}
 {:src "https://github.com/nvim-lua/plenary.nvim"}]
```

To support this we can match on the return value to see if it's a list, and then loop and insert each spec in the list, otherwise we do as before:

{path="fnl/plugins/init.fnl" hl="7..14"}
```fennel
(local specs (accumulate [acc [] _ abs_path (ipairs paths)]
               (do
                 (local path (string.match abs_path "(plugins/[^./]+)%.fnl$"))
                 (if (and path (not= path "plugins/init"))
                     (do
                       (local mod_res (require path))
                       (case mod_res
                         ;; Flatten return if we return a list of specs.
                         [specs]
                         (each [_ spec (ipairs mod_res)]
                           (table.insert acc spec))
                         ;; Can return a string or a single spec.
                         _
                         (table.insert acc mod_res))
                       acc)
                     acc))))
```

Now all that's left is to call [vim.pack.add][] with our list of specs and our plugins are now automatically added from files under `plugins/`:

{path="fnl/plugins/init.fnl"}
```fennel
(vim.pack.add specs {:confirm false})
```

## Lazy loading with [lze][]

[lze][] is a pretty nice and simple plugin to add lazy-loading to [vim.pack][].

We've already added it as a dependency in our `init.lua` so all we need to do is modify the `load` parameter to `vim.pack.add` like so:

{path="fnl/plugins/init.fnl"}
```fennel
;; Override loader when adding to let lze handle lazy loading
;; when specified via the `data` attribute.
(vim.pack.add specs {:load (fn [p]
                             (local spec (or p.spec.data {}))
                             (set spec.name p.spec.name)
                             (local lze (require :lze))
                             (lze.load spec))
                     :confirm false})
```

Now we can specify lazy loading via the `data` parameter in our specs:

{path="fnl/plugins/misc.fnl"}
```fennel
{:src "https://github.com/romainl/vim-cool"
 :data {:event ["BufReadPost" "BufNewFile"]}}
```

It relies on wrapping configuration under `data` but that's annoying, so let's simplify things a little.

## Simplified specifications

The idea here is to transform the specs before we call [vim.pack.add][].

We can do it easily when we collect our specs by calling the `transform_spec` function:

{path="fnl/plugins/init.fnl" hl="10,12"}
```fennel
(local specs (accumulate [acc [] _ abs_path (ipairs paths)]
               (do
                 (local path (string.match abs_path "(plugins/[^./]+)%.fnl$"))
                 (if (and path (not= path "plugins/init"))
                     (do
                       (local mod_res (require path))
                       (case mod_res
                         [specs]
                         (each [_ spec (ipairs mod_res)]
                           (table.insert acc (transform_spec spec)))
                         _
                         (table.insert acc (transform_spec mod_res)))
                       acc)
                     acc))))
```

I want `transform_spec` to transform this:

```fennel
{:src "https://github.com/romainl/vim-cool"
 :event ["BufReadPost" "BufNewFile"]}
```

Into this:

```fennel
{:src "https://github.com/romainl/vim-cool"
 :data {:event ["BufReadPost" "BufNewFile"]}}
```

By storing keys other than `src`, `name`, and `version` under a `data` table.
This is what I came up with:

{path="fnl/plugins/init.fnl"}
```fennel
(λ transform_spec [spec]
  "Transform a vim.pack spec and move lze arguments into `data`"
  (case spec
    {}
    (do
      ;; Split keys to vim.pack and rest into `data`.
      (local pack_args {})
      (local data_args {})
      (each [k v (pairs spec)]
        (if (vim.list_contains [:src :name :version] k)
            (tset pack_args k v)
            (tset data_args k v)))
      (set pack_args.data data_args)
      pack_args)
    ;; Bare strings are valid vim.pack specs too.
    other
    other))
```

Another quality of life feature I'd like is to make it simpler to call `setup` functions.
[lazy.nvim][] again does this well and it's pretty convenient.

For example, this is how it looks like with [lze][] to add an `after` hook and call a `setup` function:

```fennel
{:src "https://github.com/A7Lavinraj/fyler.nvim"
 :on_require :fyler
 :after (λ []
          (local fyler (require :fyler))
          (fyler.setup {:icon_provider "nvim_web_devicons"
                        :default_explorer false}))}
```

What if we could instead do:

```fennel
{:src "https://github.com/A7Lavinraj/fyler.nvim"
 :on_require :fyler
 :setup {:icon_provider "nvim_web_devicons" :default_explorer false}}]
```

But this is just data and we can transform the second case to the first one fairly easily.
In the `transform_spec` function:

{path="fnl/plugins/init.fnl" hl="15..24"}
```fennel
(λ transform_spec [spec]
  "Transform a vim.pack spec and move lze arguments into `data`
   and create an `after` hook if `setup` is specified."
  (case spec
    {}
    (do
      ;; Split keys to vim.pack and rest into `data`.
      (local pack_args {})
      (local data_args {})
      (each [k v (pairs spec)]
        (if (vim.list_contains [:src :name :version] k)
            (tset pack_args k v)
            (tset data_args k v)))

      (λ after [args]
        ;; Call `setup()` functions if needed.
        (when spec.setup
          (local pkg (require spec.on_require))
          (pkg.setup spec.setup))
        ;; Load user specified `after` if it exists.
        (when spec.after
          (spec.after args)))

      (set data_args.after after)
      (set pack_args.data data_args)
      pack_args)
    ;; Bare strings are valid vim.pack specs too.
    other
    other))
```

The one issue is how to figure out the package name to require (since it may differ from the path).
I chose to use the `on_require` argument that [lze][] uses as the keyword so it can lazy load on require (on `(require :fyler)`{=fennel} for example).

And just to prevent me from making mistakes, I added a sanity check:

{path="fnl/plugins/init.fnl" hl="1..5"}
```fennel
;; `:setup` needs to know what package to require,
;; therefore we use `:on_require`
(when (and spec.setup (not spec.on_require))
  (error (.. "`:setup` specified without `on_require`: "
             (vim.inspect spec))))

(λ after [args]
  ;; ...
```

## Build scripts via PackChanged events

There's one last feature I really want from [lazy.nvim][] and that's to automatically run build scripts after a package is installed or updated.

I basically want to specify this in my specs:

```fennel
{:src "https://github.com/eraserhd/parinfer-rust"
 :build ["cargo" "build" "--release"]}
```

Again, we'll use rely on [PackChanged][] for this:

```fennel
;; Before `vim.pack.add` to capture changes.
(augroup! :plugin_init (au! :PackChanged pack_changed))
```

The above code uses macros from [nvim-laurel][] to define an autocommand that calls the `pack_changed` function.
That function will then run the build script when the package is updated or installed:

```fennel
(λ pack_changed [event]
  (when (vim.list_contains [:update :install] event.data.kind)
    ;; This is ugly, but `?.` will prevent crashing.
    ;; It's nested this way because the `build` parameter gets
    ;; moved into to `data` key in specs.
    (local build (?. event :data :spec :data :build))
    (when build
      (run_build_script build event))))
  ;; Return false to not remove the autocommand.
  false)
```

To run the scripts I use [vim.system][] with some simple printing:

```fennel
(λ run_build_script [build event]
  (local path event.data.path)
  (vim.notify (.. "Run `" (vim.inspect build) "` for " event.data.spec.name)
              vim.log.levels.INFO)
  (vim.system build {:cwd path}
              (λ [exit_obj]
                (when (not= exit_obj.code 0)
                  ;; If I use `vim.notify` it errors with:
                  ;; vim/_editor.lua:0: E5560: nvim_echo must not be called in a fast event context
                  ;; Simply printing is fine I guess, it doesn't have to be the prettiest solution.
                  (print (vim.inspect build) "failed in" path
                         (vim.inspect exit_obj))))))
```

This will now allow us to run build scripts like `cargo build --release` or `make` after a package is installed or updated.
It's a bit too basic as there's no visible progress bar for long running builds (Rust, I'm looking at you!) but it works well enough I guess.

But what about user commands or requiring a package? For example with [nvim-treesitter][] you'd want to run `:TSUpdate` after an update.
Something like this:

```fennel
{:src "https://github.com/nvim-treesitter/nvim-treesitter"
 :version :main
 :build #(vim.cmd "TSUpdate")}
```

Let's try it by allowing functions in the `build` parameter (and bare strings because why not):

{path="fnl/plugins/init.fnl" hl="6..11,14..17"}
```fennel
(λ pack_changed [event]
  (when (vim.list_contains [:update :install] event.data.kind)
    (set_pack_changed event.data.spec.name event)
    (local build (?. event :data :spec :data :build))
    (when build
      (case (type build)
        ;; We can specify either "make" or ["make"]
        "string" (run_build_script [build] event)
        "table" (run_build_script build event)
        ;; Run a callback instead
        "function" (call_build_cb build event))))
  false)

(λ call_build_cb [build event]
  (vim.notify (.. "Call build hook for " event.data.spec.name)
              vim.log.levels.INFO)
  (build event))
```

If we run this though it doesn't work:

```
Error in /home/tree/code/nvim-conf/init.lua..PackChanged Autocommands for "*":
Lua callback: vim/_editor.lua:0: /home/tree/code/nvim-conf/init.lua..PackChanged Autocommands for "*"..script nvim_exec2() called
at PackChanged Autocommands for "*":0, line 1: Vim:E492: Not an editor command: TSUpdate
```

The problem is that `PackChanged` is run before the pack is loaded.
Maybe we could work around this by calling [packadd][] ourselves but that would shortcut lazy loading.
In this instance we'd like to run `TSUpdate` after the pack is loaded but only if it's been updated or installed so we don't run it after every restart.

What I did was introduce an `after_build` parameter to the spec that should do this:

{hl=3}
```fennel
{:src "https://github.com/nvim-treesitter/nvim-treesitter"
 :version :main
 :after_build #(vim.cmd "TSUpdate")}
```

Then in `plugins/init.fnl` I use a local variable `packs_changed` that's updated on [PackChanged][] like so:

{path="fnl/plugins/init.fnl" hl="1..8,12"}
```fennel
;; Capture packs that are updated or installed.
(g! :packs_changed {})

(λ set_pack_changed [name event]
  ;; Maybe there's an easier way of updating a global...?
  (var packs vim.g.packs_changed)
  (tset packs name event)
  (g! :packs_changed packs))

(λ pack_changed [event]
  (when (vim.list_contains [:update :install] event.data.kind)
    (set_pack_changed event.data.spec.name event)
    (local build (?. event :data :spec :data :build))
    (when build
      (case (type build)
        "string" (run_build_script [build] event)
        "table" (run_build_script build event)
        "function" (call_build_cb build event))))
  false)
```

Then we'll call `after_build` from the `after` hook we setup before:

{path="fnl/plugins/init.fnl" hl="9..10,14..17"}
```fennel
(λ transform_spec [spec]
  (case spec
    {}
    (do
      ;; Split keys to vim.pack and rest into `data`.
      ;; ...

      (λ after [args]
        (local pack_changed_event (. vim.g.packs_changed args.name))
        (set_pack_changed args.name false)
        (when spec.setup
          (local pkg (require spec.on_require))
          (pkg.setup spec.setup))
        ;; Run `after_build` scripts if a `PackChanged` event
        ;; was run with `install` or `update`.
        (when (and spec.after_build pack_changed_event)
          (spec.after_build args))
        (when spec.after
          (spec.after args)))

      (set data_args.after after)
      (set pack_args.data data_args)
      pack_args)
    other
    other))
```

With this we can finally specify build actions such as these:

```fennel
{:build ["cargo" "build" "--release"]
 :after_build #(vim.cmd "TSUpdate")}
```

# Some Fennel examples

You've already seen how Fennel code looks like but what about configuration with Fennel?
One of the negative things of moving my configuration from Vimscript to Lua was that simple things such as settings options or simple keymaps became a bit more verbose.

So how does Fennel compare for the simpler, more declarative stuff?

## Options

```vim
set relativenumber
set clipboard^=unnamed,unnamedplus
set backupdir=~/.vim/backup
let mapleader=" "
```

```lua
vim.opt.relativenumber = true
vim.opt.clipboard:append({ "unnamed", "unnamedplus" })
vim.opt.backupdir = vim.fn.expand("~/.config/nvim/backup")
vim.g.mapleader = [[ ]]
```

```fennel
(set! :relativenumber true)
(set! :clipboard + ["unnamed" "unnamedplus"])
(set! :backupdir (vim.fn.expand "~/.config/nvim/backup"))
(g! :mapleader " ")
```

With [nvim-laurel][] macros I think Fennel is decent.
Slightly better than Lua but not as convenient as Vimscript.

[nvim-laurel]: https://github.com/aileot/nvim-laurel

## Keymaps

```lua
local map = vim.keymap.set
map("n", "<localleader>D", vim.lsp.buf.declaration,
  { silent = true, buffer = buffer, desc = "Declaration" }
)
map("n", "<leader>ep", function() find_org_file("projects") end,
  { desc = "Org projects" }
)
```

```fennel
(bmap! :n "<localleader>D" vim.lsp.buf.declaration
       {:silent true :desc "Declaration"})
(map! :n "<leader>ep" #(find_org_file "projects")
      {:desc "Org projects"})
```

Not a huge difference to be honest.
I like the `#(do_the_thing)` shorthand for anonymous functions fennel has though.

## Overriding highlight groups

One example that was a big step up with Fennel is overriding highlight groups.
I'm using [melange][] which is a fantastic and underrated color scheme but I've collected a fair bit of overrides for it.

In Lua you use [nvim\_set\_hl][] to add an override, for example like this:

```lua
vim.api.nvim_set_hl(0, "@symbol.elixir", { link = "@label" })
```

When you do this 100 times this is _annoying_ so I made an override table to accomplish the job:

```lua
local overrides = {
  { name = "@symbol.elixir", val = { link = "@label" } },
  { name = "@string.special.symbol.elixir", val = { link = "@label" } },
  { name = "@constant.elixir", val = { link = "Constant" } },
  -- And around 100 other overrides...
}

for _, v in pairs(overrides) do
  vim.api.nvim_set_hl(0, v.name, v.val)
end
```

In Fennel with the [hi!][] macro this all becomes as simple as:

```fennel
(hi! "@symbol.elixir" {:link "@label"})
(hi! "@string.special.symbol.elixir" {:link "@label"})
(hi! "@constant.elixir" {:link "Constant"})
;; etc
```

## Autocommands

Here are some autocommands to enable [cursorline][] only in the currently active window (while skipping buffers such as the dashboard):

```lua
local group = augroup("my-autocmds", { clear = true })
autocmd({ "VimEnter", "WinEnter", "BufWinEnter" }, {
  group = group,
  callback = function(x)
    if string.len(x.file) > 0 then
      vim.opt_local.cursorline = true
    end
  end,
})
autocmd("WinLeave", {
  group = group,
  callback = function()
    vim.opt_local.cursorline = false
  end,
})
```

```fennel
(augroup! :my-autocmds
          (au! [:VimEnter :WinEnter :BufWinEnter]
               #(do
                  (when (> (string.len $1.file) 0)
                    (let! :opt_local :cursorline true))
                  false))
          (au! :WinLeave #(do
                            (let! :opt_local :cursorline false)
                            false)))
```

## Plugin specs

One thing I like more in Lua compared to Fennel is how readable tables are.
The Fennel formatter [fnlfmt][] might be partly to blame as it has a tendency to use very little whitespace. Regardless, I prefer this Lua code:

```lua
return {
  "https://github.com/stevearc/conform.nvim",
  { src = "https://github.com/mason-org/mason.nvim", dep_of = "mason-lspconfig.nvim" },
  { src = "https://github.com/neovim/nvim-lspconfig", dep_of = "mason-lspconfig.nvim" },
  "https://github.com/mason-org/mason-lspconfig.nvim",
  {
    src = "https://github.com/nvim-treesitter/nvim-treesitter",
    version = "main",
    after = function()
      vim.cmd("TSUpdate")
    end,
  },
}
```

Over this corresponding Fennel code:

```fennel
["https://github.com/stevearc/conform.nvim"
 {:src "https://github.com/mason-org/mason.nvim" :dep_of :mason-lspconfig.nvim}
 {:src "https://github.com/neovim/nvim-lspconfig" :dep_of :mason-lspconfig.nvim}
 "https://github.com/mason-org/mason-lspconfig.nvim"
 {:src "https://github.com/nvim-treesitter/nvim-treesitter"
  :version :main
  :after #(vim.cmd "TSUpdate")}
```

To me the Lua code is for some reason easier to read.

Similarly I don't have a problem with this [lazy.nvim][] spec:

```lua
return {
  "folke/snacks.nvim",
  priority = 1000,
  lazy = false,
  opts = {
    indent = {
      indent = {
        enabled = true,
        char = "┆",
      },
      scope = {
        enabled = true,
        only_current = true,
      },
    },
    scroll = {
      animate = {
        duration = { step = 15, total = 150 },
      },
    },
    explorer = {},
  },
}
```

But with this new Fennel spec I use---even though it's simpler in some ways---it's harder for me to quickly see what table the keys belong to:

```fennel
{:src "https://github.com/folke/snacks.nvim"
 :on_require :snacks
 :lazy false
 :setup {:indent {:indent {:enabled true :char "┆"}
                  :scope {:enabled true :only_current true}}
         :scroll {:animate {:duration {:step 15 :total 150}}}
         :explorer {}}}
```

Maybe it's something you'll get used to; or it's something I can tweak using better syntax highlighting, formatting settings, or something else.

::: note
A big plus with the setup I use is that I can mix Funnel and Lua, so if I want to I could specify the plugin specs in Lua and have the more "codey" parts in Fennel.
:::

# Notable plugin updates

## Native undotree

I've been using the [undotree][undotree-plugin] a long time and it's excellent.
[This feature][nvim-undotree] was [recently merged into Neovim](https://github.com/neovim/neovim/pull/35627):

[undotree-plugin]: https://github.com/jiaoshijie/undotree
[nvim-undotree]: https://neovim.io/doc/user/plugins.html#_builtin-plugin:-undotree

```fennel
;; It's optional so we need to use packadd to activate the plugin:
(vim.cmd "packadd nvim.undotree")
;; Then we can add a keymap to open it:
(map! :n "<leader>u" #(: (require :undotree) :open {:command "topleft 30vnew"}))
```

## Simplified LSP config

Neovim routinely gets shit on for LSPs being so hard to setup.
Yes, it could probably be easier but Neovim has recently made some changes and it's not nearly as involved as it used to be.

Here's how my base config looks like:

{path="fnl/config/lsp.fnl"}
```fennel
(require-macros :macros)

;; Convenient way of installing LSPs and other tools.
(local mason (require :mason))
(mason.setup)

;; Convenient way of automatically enabling LSPs installed via Mason.
(local mason-lspconfig (require :mason-lspconfig))
(mason-lspconfig.setup {:automatic_enable true})

;; Show diagnostics as virtual lines on the current line.
(vim.diagnostic.config {:virtual_text false
                        :severity_sort true
                        :virtual_lines { :current_line true })

;; I like inlay hints.
(vim.lsp.inlay_hint.enable true)

(augroup! :my-lsps
          (au! :LspAttach
               (λ [_]
                 (bmap! :n "<localleader>D" vim.lsp.buf.declaration
                        {:silent true :desc "Declaration"})
                 (bmap! :n "<localleader>l"
                        #(vim.diagnostic.open_float {:focusable false})
                        {:silent true :desc "Diagnostics"})
                ;; etc
```

I also use [nvim-lspconfig][] but it doesn't do anything magical (anymore).
It's basically a [collection of LSP configs][], so I don't have to fill my config with things like this:

```fennel
(vim.lsp.config "expert"
                {:cmd ["expert"]
                 :root_markers ["mix.exs" ".git"]
                 :filetypes ["elixir" "eelixir" "heex"]})

(vim.lsp.enable "expert")
```

If you don't want to change the keymaps (Neovim comes with defaults that I personally dislike) or customize specific LSPs then there's not that much left.
[Mason][] is also totally optional and if you want to manage your LSPs outside of Neovim you can totally do that.
The only thing missing is autocomplete, which [blink.cmp][] provides out of the box.

## Automatically install and enable treesitter grammars

Another thing that has changed since my last config overhaul is [nvim-treesitter][] being rewritten and is now a much simpler plugin. The new version lives on the [main branch][main-treesitter] and the old archived one on `master` and it contains a bunch of breaking changes.

For example, it no longer supports installing and activating grammars automatically.
I think I saw a plugin for that somewhere but here's some Fennel code that sets it up:

{path="fnl/config/treesitter.fnl"}
```fennel
(require-macros :macros)

(local nvim-treesitter (require :nvim-treesitter))

;; Ignore auto install for these filetypes:
(local ignored_ft [])

(augroup! :treesitter
          (au! :FileType
               (λ [args]
                 (local bufnr args.buf)
                 (local ft args.match)
                 ;; Auto install grammars unless explicitly ignored.
                 (when (not (vim.list_contains ignored_ft ft))
                   (: (nvim-treesitter.install ft) :await
                      (λ []
                        ;; Enable highlight only if there's an installed grammar.
                        (local installed (nvim-treesitter.get_installed))
                        (when (and (vim.api.nvim_buf_is_loaded bufnr)
                                   (vim.list_contains installed ft))
                          (vim.treesitter.start bufnr))))))))
```

If you use [nvim-treesitter-textobjects][] (which you should) remember to migrate to the `main` branch there too.

## Some new fun plugins

* [fyler.nvim][]
* [blink.nvim][]
* [snacks.nvim][] picker
* Project wide query replace?

[hi!]: https://github.com/aileot/nvim-laurel/blob/main/docs/reference.md#highlight
[scructured plugins]: https://lazy.folke.io/usage/structuring
[vim.pack.Spec]: https://neovim.io/doc/user/pack.html#vim.pack.Spec
[-> threading macro]: https://fennel-lang.org/reference#------and---threading-macros
[vim.pack.add]: https://neovim.io/doc/user/pack.html#vim.pack.add()
[PackChanged]: https://neovim.io/doc/user/pack.html#PackChanged
[vim.system]: https://neovim.io/doc/user/lua.html#vim.system()
[melange]: https://github.com/savq/melange-nvim
[main-treesitter]: https://github.com/nvim-treesitter/nvim-treesitter/tree/main
[packadd]: https://neovim.io/doc/user/repeat.html#%3Apackadd
[collection of LSP configs]: https://github.com/neovim/nvim-lspconfig/tree/master/lsp
[Mason]: https://github.com/mason-org/mason.nvim
[nvim-treesitter-textobjects]: https://github.com/nvim-treesitter/nvim-treesitter-textobjects/tree/main
[Neovim :help station]: https://neovim.io/doc/user/helphelp.html
[Fennel safety manual]: https://fennel-lang.org/reference

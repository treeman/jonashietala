---toml
title = "Extending Neovim for my blog"
tags = ["Lua",  "Rust",  "Webpage"]
---

::: epigraph
> Scripting is configuration. Configuration is scripting.
> ^ TJ DeVries [A different take on editing code](https://www.youtube.com/watch?v=QMVIJhC9Veg)
:::

I've been using Neovim since it forked from Vim almost 8 years ago, and I used Vim many years before that.
I feel quite comfortable with Neovim, and I've gone down the [configuration rabbit hole][] too many times I'd like to admit, but I never dived deeper by writing something truly custom like a plugin.

That changed when I got inspired by the excellent [Developing a Neovim Docker Plugin from Scratch][] where the creator goes through how to extend [telescope.nvim][] in a very pedagogical manner.

I ended up extending Neovim and my blog backend with some sorely needed features such as:

1. Browse posts using [telescope.nvim][].
1. Autocomplete post urls, link definitions, and more using [nvim-cmp][].
1. Goto definition.
1. Diagnostics.
1. Browser preview with auto refresh and scroll.

This post will go through how I implemented the above features.
The focus will be on Neovim and Lua side of things, but I'll call out some backend Rust details too.

# Initial setup

While I could develop this as a normal plugin, because it's so coupled to my setup I decided to organize it under `nvim/lua/blog` and simply include it in my init script:

```lua
require("blog")
```

This calls `nvim/lua/blog/init.lua` that in turn requires other initialization files:

```lua
require("blog.autocmd")
require("blog.cmp")
require("blog.commands")
```

Another quirk of my [Neovim config][] is that I've tried to collect all keymaps in one file, where I added some new keymaps for the blog:

```lua
local map = vim.keymap.set

M.init = function()
  map("n", "gd", require("blog.telescope").find_draft, { desc = "Find blog draft" })
  map("n", "gp", require("blog.telescope").find_post, { desc = "Find blog post" })
  -- Lots of other things...
end

M.buf_blog = function(buffer)
  map("n", "<localleader>t", require("blog.telescope").find_tags, { buffer = buffer, desc = "List tags" })
  map("i", "<C-t>", require("blog.telescope").find_tags, { buffer = buffer, desc = "List tags" })
  map("n", "<localleader>d", require("blog.interaction").goto_def, { buffer = buffer, desc = "Goto definition" })
end
```

Where `buf_blog` is called by an autocommand when editing a blog post.

That's it for hooking up the code into my Neovim setup, now let's look at what the code does.

# Creating and moving posts

Let's start by moving some functionality from the blog generation backend to Neovim:

- Creating a draft with a small template.
- Promote a draft to a blog post and demote a post back to a draft.

I don't really know why I had these implemented as commands line arguments to the backend---they fit much better in Neovim.

They're implemented as user commands:

```lua
local cmd = require("util").create_cmd
local files = require("blog.files")

-- Create a new draft, promote it to a post, or revert it back to a draft.
cmd("BlogNewDraft", files.new_draft)
cmd("BlogPromoteDraft", files.promote_curr_draft)
cmd("BlogDemotePost", files.demote_curr_post)
```

Where `create_cmd` is a small helper snippet I stole from somewhere:

```lua
M.create_cmd = function(command, f, opts)
  opts = opts or {}
  vim.api.nvim_create_user_command(command, f, opts)
end
```

## New draft

Creating a draft should do two simple things:

1. Create a file at `drafts/some_title.dj` under the blog directory.
2. Open it and fill in some placeholder data.

Creating a file can be done using `vim.cmd` to send the `:edit` command.

Inserting text from lua was harder, I tried to search for help with `:Telescope help_tags` but came up short.
In the end I found `vim.api.nvim_buf_set_lines` via Google that can be used to insert lines.

This is the solution I came up with:

```lua
local path = require("blog.path")
local nio = require("nio")

-- A module file in lua by convention use an `M` table,
-- allowing us to call `require("blog.files").new_draft()`.
local M = {}

M.new_draft = function()
  nio.run(function()
    -- Prompt for the title of the new draft.
    local title = nio.ui.input({ prompt = "Draft title: " })

    -- Create and open the draft for edit (without checking if it exists...)
    -- `path.blog_path` expands to the path to my blog and `slugify` converts
    -- a title to a slug by replacing spaces with underscores and removing symbols.
    local file_path = path.blog_path .. "drafts/" .. M.slugify(title) .. ".dj"
    vim.cmd(":e " .. file_path)

    -- The text the draft will start with.
    local template = {
      "---toml",
      'title = "' .. title .. '"',
      'tags = ["Some tag"]',
      "---",
    }
    -- Insert the text into the current buffer at row 0 (to 0).
    local buf = vim.api.nvim_get_current_buf()
    vim.api.nvim_buf_set_lines(buf, 0, 0, true, template)
  end)
end

return M
```

I hope it's clear what the above code is doing, but I want to call out the usage of [nvim-nio][].
It's a great library that makes asynchronous programming simple in Neovim.

To start an async task you use `nio.run`:

```lua
nio.run(function()
  -- Code here is run async
end)
```

For this example of creating a new draft async is overkill.
Async is required for some other situations and it's easy to add so I use it liberally, even when not strictly needed.

## Moving files

In my blogging setup I store posts under `posts/` with the release date in the path, and drafts under `drafts/`.
So promoting and demoting is accomplished by moving the file:

- Promote a draft to a post by moving it from `drafts/post_title.dj` to `posts/2024-04-14-post_title.dj`.
- Demote a post by moving it from `posts/2024-04-14-post_title.dj` to `drafts/post_title.dj`.

I'm not going to include all the code here, but here are the most important implementation details:

1. Extract the title from the post by shelling out to [ripgrep][].

   [nvim-nio][] provides `process.run` to run a shell command:

   ```lua
   local proc = nio.process.run(args)
   proc.stdout.read()
   ```

   That we can run [ripgrep][] to search for the title:

   ```lua
   {
     cmd = "rg",
     args = {
       "-NoH",
       "^title = (.+)",
       path,
     },
   }
   ```

   ::: notice
   Another solution would be to rely on the backend to provide the title.
   It would be more robust since the backend properly parses the file,
   but when I first created this function I didn't have the backend connection.
   :::

1. Create the destination path.

   When promoting a draft for example:

   ```lua
   path.blog_path .. "posts/" .. os.date("%Y-%m-%d") .. "-" .. M.slugify(title) .. ".dj"
   ```

1. Move the file.

   I don't know what the idiomatic way to rename a file is, or even how to do it in Neovim.
   But I do know that with `:!` you can call an external program... Like `mv`!

   So here's an ugly way to rename the current file:

   ```lua
   vim.cmd(":!mv " .. from .. " " .. to)
   vim.cmd(":e " .. to)
   ```

   Because everything is done in an async context (inside `nio.run`) we run into a problem: we can't call the Neovim API without yielding to the Neovim scheduler.

   What we need to do is call `scheduler` before we rename the file:

   ```lua
   nio.scheduler()
   -- Now we can call `vim.cmd` and `vim.fn`.
   ```

# Browse posts with [telescope.nvim][]

I've used [telescope.nvim][]\'s find files with `require("telescope.builtin").find_files`lua for quite some time.
I use find files together with it's cousin `.oldfiles` (find recently opened files) all the time for finding source code files, blog posts, and more.

But it's naturally restricted to operate on only filenames and you can make telescope richer by operating on structured data.

So let's move away from using the files finder to find posts:

![](/images/extend_blog/find_files.png)

To a custom posts picker that display posts in a neater way and allows us to filter using tags or other metadata:

![](/images/extend_blog/find_posts.png)

## The simplest picker

It's fairly easy to create a new picker for [telescope.nvim][].
In it's simplest form, all you need to do is provide a list of items to `telescope.pickers`:

```lua
local pickers = require("telescope.pickers")
local finders = require("telescope.finders")

pickers
  .new(opts, {
    finder = finders.new_table({
      results = { "One", "Two", "Three" },
    }),
  })
  :find()
```

::: notice
How do I know this?
Because I watched [Developing a Neovim Docker Plugin from Scratch][].
It does a way better job walking you through a telescope plugin than I could ever do.
:::

## Structured content

To make our simple picker handle structured content we need to:

1. Convert `results` to a list of tables with the info we have.
1. Specify an `entry_marker` function.

It essentially looks like this:

```lua
finder = finders.new_table({
  -- 1. Structured data inside `results`.
  results = {
    { title = "One", tags = "Tag1, Tag2", path = "posts/2024-01-01-one.dj" },
    { title = "Two", tags = "Tag2", path = "posts/2024-02-02-two.dj" },
  },
  -- 2. A function that converts a result entry to an entry telescope understands.
  entry_maker = function(entry)
    return {
      -- Display the post title instead of the path in the list.
      display = entry.title,
      -- Allow us to filter against the title and tags (typing `Tag1` finds the "One" post).
      ordinal = entry.title .. entry.tags,
      -- Save the whole entry for future usage.
      value = entry,
    }
  end,
}),
```

With this the finder displays the title of the post rather than the file path, and we can search for a post using the title and its tags.
In my post picker I also display the date and allow you to filter by [series](/series) id.

I tried to have the path in the ordinal as well, but because of the fuzzy matching the path cluttered the search result by including way too many posts.

## File preview

One of the great features of [telescope.nvim][] is the very fast preview with syntax highlighting, which we of course must configure.

I searched through the telescope help, and found the functions `new_buffer_previewer` and `buffer_previewer_maker` that allows us to define a previewer for a file:

```lua
local previewers = require("telescope.previewers")

finder = finders.new_table({
  -- ...

  previewer = previewers.new_buffer_previewer({
    -- Title isn't needed.
    title = "Post Preview",
    define_preview = function(self, entry)
      -- Notice `entry.value.path` that uses our catch-all entry value.
      conf.buffer_previewer_maker(entry.value.path, self.state.bufnr, {
        bufname = self.state.bufname,
        winid = self.state.winid,
        preview = opts.preview,
        -- The file encoding is needed for proper syntax highlighting.
        file_encoding = opts.file_encoding,
      })
    end,
  }),
})
```

I'm not sure if there's a less verbose way to define a file previewer, as the only thing I really configured here is the title and the `entry.value.path` argument to `buffer_preview_maker`.

## Open the selected file

We already have configured the display of our [telescope.nvim][] picker configured.
The only question left is how do we open the file once we've found it?

The answer is yet another argument to `finders.new_table` called `attach_mappings`:

```lua
local actions = require("telescope.actions")

finder = finders.new_table({
  -- ...
  attach_mappings = function(prompt_bufnr)
    actions.select_default:replace(function()
      local selection = action_state.get_selected_entry()
      actions.close(prompt_bufnr)
      vim.cmd(":e " .. selection.value.path)
    end)
    return true
  end,
})
```

The above mapping overrides the default selection action (`<CR>` in my case) to `:edit` `value.path` of our selection, which will open the selected file.

Multiselection is possible in telescope, which you need to handle in the mapping function if you want to support it.

## Finding the post data to populate the picker

So far I've only used placeholder data for the posts, but of course I need to search the file system for the markup files for the posts.

How did I extract the post metadata, which is defined inside the posts in a frontmatter?
This is a frontmatter that's defined at the start of every markup file:

```
---toml
title = "Let's build a VORON: Noise"
tags = ["3D printing", "VORON"]
series = "voron_trident"
---
```

With [ripgrep][] and regex of course!

This time though I have a good reason for choosing an external tool rather than asking the backend server:
I want to be able to find a post the very first thing I do when opening Neovim, and I don't want to wait on connecting to a backend service, or requiring one running at all times.

The strategy is to use [ripgrep][] to match the frontmatter in all posts, extract the metadata using some hacky Lua regex, and combine them into a post struct we can feed into the [finder we developed](#Structured-content).

This is one way to find all posts under a path and extract the frontmatter using [ripgrep][]\'s regex syntax:

```lua
nio.process.run({
  cmd = "rg",
  args = {
    "-NoHU",
    "--heading",
    "\\A\\---\\w*\\n(.+\\n)+^---",
    -- subpath could be `posts/` or `drafts/`, using absolute paths
    path.blog_path .. subpath,
  },
})
```

Which will produce output formatted like this:

```
posts/2016-07-29-slackware_installation_notes.markdown
---
layout: post
title: "Slackware installation notes"
tags: Slackware
---

posts/2019-01-25-site_restyle_and_update.markdown
---
title: "Site restyle and update"
tags: ["Webpage", "Web Design"]
---
```

My code for splitting the output and extracting the metadata is a little gross, but I don't know how to make it prettier:

```lua
local lines = vim.fn.split(output, "\n")
local posts = {}

local post = {}
for _, line in ipairs(lines) do
  -- When a newline is encountered save the post and prepare for the next entry.
  if line == "" then
    if post.title then
      table.insert(posts, post)
    end
    post = {}
  -- Skip `---` markers.
  elseif not string.match(line, "%-%-%-%w*") then
    -- Try to extract all key value definitions and store them.
    local key, value = string.match(line, "(%w+)%s*[:=]%s*(.+)")
    if key then
      -- Strip surrounding quotes.
      -- Do this here because there's no non-greedy specifier that could be used
      -- in the key/value regex above.
      local stripped = string.match(value, '^"(.+)"$')
      if stripped then
        value = stripped
      end
      post[key] = value
    else
      -- If no key value pair is found, then we should be at the beginning with the file path.
      post["path"] = line
      -- Only posts have a date in the path, not drafts.
      local date = string.match(line, "posts/(%d%d%d%d%-%d%d%-%d%d)%-")
      if date then
        post["date"] = date
      end
    end
  end
end
-- If output ends we might have an unsaved post.
if post.title then
  table.insert(posts, post)
end
```

Yes, I'm using regex to parse `yaml`/`toml` values.

I could try to find a lua parser, but eeeh...

![](/images/extend_blog/regex_this_is_fine.jpg)

It does mean we have a working [telescope.nvim][] picker!
I may have skipped some details, so [take a look at the source code](https://github.com/treeman/dotfiles/blob/master/.config/nvim/lua/blog/telescope.lua) if you're interested.

# Communicating with the backend process

I've referred to "the backend" a bunch, but what is it and why do we need one?

First thing to keep in mind is that my blog is a static site.
There's no backend that serves content, it's just files that I serve directly from Amazon S3.
To create these files I have a [static site generator][blog_code] (command line program) that converts markup files to HTML files.
There's no need for a backend here.

Except that the writing experience isn't so great if you always have to regenerate the site using the command line and search for the output file in your file system if you just want to view the site in the browser.

I therefore have a small web server using [axum][] built into the site generator.
It's used to serve the site at `localhost:8080` and uses [hotwatch][] to automatically rebuild the site when I write.
This is what I've been calling "the backend", even though it's only used locally.

If we could open a connection and make Neovim communicate with the backend, we could do cool things like autocomplete any site url (which is very different from autocompleting file paths), or jump to link definitions and relative urls.

## Sockets in Neovim

I had no idea on how to communicate with Neovim, but after perusing Neovim's generally great `:help` pages together with some intense Googling I found some building blocks that allowed me to cobble together a working solution:

- `vim.fn.sockconnect` allows us to connect to a socket.

  It comes with an `on_data` callback to receive messages.

- `vim.fn.chansend` to send messages.

- `vim.fn.json_encode` and `vim.fn.json_decode` to convert between json and Lua tables.

- [nvim-nio][] to make the communication async and allows us to build a nice API.

Let's jump right into the code.
This code connects to a socket:

```lua
-- Use `pcall` to catch connection errors.
-- If status is true we cnnected, otherwise `err` describes the error.
local status, err = pcall(function()
  -- Save the channel id in the local module, used to send messages.
  M._blog_conn = vim.fn.sockconnect("tcp", "127.0.0.1:8082", {
    on_data = function(_, data, _)
      nio.run(function()
        -- We received `data` from the socket, handle it async here.
      end)
    end,
  })
end)
```

When we try to connect to the socket it might error, wrapping it in a `pcall` stops the error from propagating.
`sockconnect` returns a channel id that we'll need when sending a message to the socket, I save it into the module variable `M._blog_conn` so other functions can access it, but you could just av well store it in a global such as `vim.g._blog_conn`.

`M._blog_conn` also allows us to see check if we're connected:

```lua
M.is_connected = function()
  return M._blog_conn ~= nil
end
```

But we also need to handle a disconnect, if the backend process exits for example.
When this happens the `data` field in the `on_data` callback will be a list with a single empty string:

```lua
vim.fn.sockconnect("tcp", "127.0.0.1:8082", {
  on_data = function(_, data, _)
  nio.run(function()
    if #data == 1 and data[1] == "" then
      vim.fn.chanclose(M._blog_conn)
      M._blog_conn = nil
      return
    else
      -- Receive a message
    end
  end)
})
```

Before going into details on how to receive a message, here's how to send a message:

```lua
local conn = M._blog_conn
if conn then
  vim.fn.chansend(conn, vim.fn.json_encode(msg))
  -- Watcher tries to read lines so we need to terminate the message with a newline
  vim.fn.chansend(conn, "\n")
else
  log.error("Trying to send a message without being connected")
end
```

Where `log` is defined using [plenary.nvim][]:

```lua
local log = require("plenary.log").new({
  plugin = "blog",
  level = "error",
})
```

Sending a message is simple, but I struggled quite a bit on how to wait for a response to the message.
I wanted an API where I could request something, wait for it, and then do something with the reply.
Maybe something like this, where a callback function is called whenever we receive a reply:

```lua
server.call({
  id = "ListUrls",
}, function(reply)
  -- `reply` should contain a list of all the urls on the site.
end)
```

The problem is: how to get the reply from the `on_data` callback into the `call` callback?
I couldn't find a channel to pass internal messages [like I use in Rust](#Channels-in-Rust), so what to do?

I figured I'll solve this by storing all replies (identified by a message id) and the `call` function can just wait until a message with a matching id has been received.

The `call` function that allows the `"ListUrls"`lua call above to work looks like this:

```lua
M.call = function(msg, cb)
  if not M.is_connected() then
    return nil
  end

  nio.run(function()
    -- Create a unique message id for the call (it's just a counter).
    local msg_id = M._gen_message_id()
    msg["message_id"] = msg_id

    -- Send the message.
    M._send_msg(msg)

    local msg_id_s = tostring(msg_id)

    -- Wait for response. 1 sec should be more than enough, otherwise we bail.
    local attempt = 0
    while attempt < 100 do
      -- `M._blog_messages` is our global message storage where we'll place all incoming
      -- messages with an id.
      if M._blog_messages then
        local reply = M._blog_messages[msg_id_s]
        if reply then
          M._blog_messages[msg_id_s] = nil
          -- We can return from `nio.run`, which will call the second callback function,
          -- defined lower down.
          return reply
        end
      end

      attempt = attempt + 1
      nio.sleep(10)
    end

    -- Response timed out.
    return false
  end,
  -- This callback is called when the above function completes.
  -- Here we call `cb` that continues the execution with the backend reply message.
  function(success, reply)
    if success and reply then
      cb(reply)
    end
  end)
end
```

Waiting like this isn't the best, but so far I haven't had any problems.
A better solution might be to use [`event`s from nvim-nio](https://github.com/nvim-neotest/nvim-nio?tab=readme-ov-file#niocontrol) but I haven't had the energy to refactor it.

When receiving a message from the socket I register it to `M._blog_messages` like this:

```lua
local reply = vim.fn.json_decode(data)

if reply["message_id"] then
  local message_id = tostring(reply["message_id"])
  local messages = M._blog_messages or {}
  messages[message_id] = reply
  M._blog_messages = messages
else
  -- Hanlde a message that's not a reply to something Neovim sent.
end
```

I think these are the most important parts of how I manage the connection, although I left out some things and simplified others.
Please see the [source code](https://github.com/treeman/dotfiles/blob/master/.config/nvim/lua/blog/server.lua) if you want more details.

## Sockets in Rust

There's probably a lot I could write on how I manage the connection and message handling on the backend,
but I wanted to focus more on the Neovim and Lua side of things for this post.

I'll list some of the more crucial parts on how I handle the connection, if you want a more complete picture please refer to the [source code](https://github.com/treeman/jonashietala/tree/master/src/server).

### Tcp connection

To open a socket we can use `TcpListener` from [tokio][].
I think I found an example somewhere in the docs on how to manage multiple connections and ended up with these steps:

1. Use `TcpListener` to bind against an address.
1. `spawn` a task that accepts new connections.
1. `spawn` another task for every new connection, which is responsible for reading and writing to that connection.

These steps might look like this in code:

```rust
use tokio::net::TcpListener;

let addr = "127.0.0.1:8082";
let listener = TcpListener::bind(addr).await?;

// Spawn a new thread that's responsible for accepting new connections
// and to spawn handlers for that connection.
tokio::spawn(async move {
    info!("tcp socket on: {addr}");
    loop {
        match listener.accept().await {
            Ok((stream, _)) => {
                tokio::spawn(async move {
                    // This thread manages a new connection to the socket
                    // and should read and write to `stream`.
                });
            }
            Err(e) => error!("Listener error: {e:?}"),
        }
    }
});
```

We're left with a thread that's responsible for reading and writing to a `TcpStream`, but how can you read _or_ write from the same thread?

You can split a `stream` into a reader and writer like so:

```rust
let (reader, writer) = stream.split();
let mut reader = BufReader::new(reader);
let mut writer = BufWriter::new(writer);
```

We now need a loop that can either read an incoming message, or write if we have a message to send.
It can be done using `tokio::select!`, which can await on multiple futures and acts on the first one that returns:;

```rust
loop {
    tokio::select! {
        msg = read_line(&mut reader) => {
            // Handle incoming message.
        }
        msg = nvim_rx.recv_async() => {
            // Write a response into `writer`.
        }
    }
}
```

This way we can accomplish our goal of both reading and writing to our socket.
But if we have a message we want to send from somewhere else in our program, how do we get it into the `select!` clause we just created?

### Channels in Rust

Notice `nvim_rx` in the `select!` clause?

`nvim_rx` is a `flume::Receiver<NeovimResponse>` from [flume][], a fast multi-producer, multi-consumer channel I use for passing messages around internally.
This kind of channel is very handy because it allows you to pass messages across threads between parts of your application.

You use the channel like this:

```rust
let (nvim_tx, nvim_rx) = flume::unbounded::<NeovimResponse>();

// Send something through the sender from anywhere in the program.
nvim_tx.send(NeovimResponse::Diagnostics { diagnostics })?,

// Receive it somewhere else.
let msg = nvim_rx.recv_async().await?;
```

Flume channels are very convenient because both senders and receivers are `Send` and `Clone`, so they work well across threads in any constellation (in contrast to the channel in `std::mpsc` that's single-consumer).

### Writing and reading

I should also mention how to do the actual reading and writing.

To make it easy to use in a `select!` clause I made this read line helper:

```rust
async fn read_line(reader: &mut BufReader<ReadHalf<'_>>) -> Result<String> {
    let mut s = String::new();
    reader.read_line(&mut s).await?;
    Ok(s)
}
```

Writing can be done like this:

```rust
let json = serde_json::to_string(&msg)?;
writer.write_all(json.as_bytes()).await?;
// I delimit messages with newlines. A bit crappy, I know.
writer.write_all("\n".as_bytes()).await?;
// Make sure to flush to send the message right away.
writer.flush().await?;
```

I estimate that these bits of knowledge takes you 80% to working with a socket in Rust.
It's just 80% left now, which I'll leave as an exercise to the reader.

# Autocompletion with [nvim-cmp][]

Creating a custom source for [nvim-cmp][] was described well in `:help cmp-develop`.

## A basic completion source

This is the basics of a source that completes a blog post path for an inline link:

```lua
local source = {}

-- The `complete` function is required.
function source:complete(params, callback)
  -- There's also the `cursor_after_line`, `cursor_line`, and a `cursor` fields on `context`.
  local cursor_before_line = params.context.cursor_before_line

  -- Regex matches `](/` to autocomplete a path in an inline link like `[link text](/path/to/post)`.
  -- The `[^%)]*$` ensures that we continue completion even
  -- after we've typed some characters and not only once after the first `/`.
  if string.match(cursor_before_line, "%]%(/[^%)]*$") then
    local items = {
      {
        -- Text to be displayed in the completion menu.
        label = "Rewriting my Neovim config in Lua",
        -- Text to insert.
        insertText = "/blog/2023/10/01/rewriting_my_neovim_config_in_lua/",
        -- Text to filter against, works like `ordinal` for telescope.
        filterText = "/blog/2023/10/01/rewriting_my_neovim_config_in_lua/|Rewriting my Neovim config in Lua",
        -- What `kind` the completion item is.
        kind = require("cmp.types.lsp").CompletionItemKind.File,
      },
      -- More items here...
    }
    callback(items)
  else
    -- `callback` should always be called.
    callback({})
  end
end

-- Trigger completion on these characters.
-- We could also trigger it manually.
function source:get_trigger_characters()
  return { "/" }
end

-- We must register our source to `cmp` like this:
require("cmp").register_source("blog", source)
```

It's also a good idea to implement the `is_available` function, to only trigger completion in the right context:

```lua
function source:is_available()
  return require("blog.server").is_connected()
end
```

```lua
cmp.setup({
  sources = {
    {
      name = "blog",
      group_index = 1,
    },
  },
  formatting = {
    format = lspkind.cmp_format({
      menu = {
        blog = "[BLOG]",
      },
    }),
  },
})
```

## What to complete where?

The completion part of the integration is the section I've had to tweak the most and it has slowly grown more complex.

It's actually pretty hard to make a complete autocomplete system.
You'd have to have a parser that's capable of parsing incomplete statements.
Maybe something like [a Tree-sitter grammar][], although the [one I created for Djot][djot-tree-sitter] doesn't mark broken things so it's useless for this purpose.
I've therefore been relying on regexes on `cursor_before_line` to select what to complete:

```lua
-- Expand images separately because I only ever use it in a -- `![](/url)`
-- context and not mixing with other urls gives a more pleasant experience.
string.match(cursor_before_line, "!%[%]%([^%)]*$")

-- Expand inline links, e.g. `[txt](/`
string.match(cursor_before_line, "%]%(/[^%)]*$")

-- Expanding headings in inline links, e.g. `[txt](#`
string.match(cursor_before_line, "%]%(#[^%)]*$")

-- Expand links in link ref definitions, e.g. `[label]: `
string.match(cursor_before_line, "^%[.+%]:%s+")

-- Expanding links in ref defs, e.g. `[label]: #`
string.match(cursor_before_line, "^%[.+%]:%s+#")

-- Expand url definition tags in `[text][tag]`
if string.match(cursor_before_line, "%[[^%]]+%]%[[^%]]*$")

-- Expand url definition tags in `[tag][]`, simplified to after a `[`
-- If at the beginning of the line, we should complete broken link tags to..
if string.match(cursor_before_line, "%[[^%]]*$")

-- Expand tags in frontmatter if line starts with `tags = `
if string.match(cursor_line, "^tags = ")

-- Expand series in frontmatter if line starts with `series = `
if string.match(cursor_line, "^series = ")
```

::: notice
As the completion logic grew more complex, I moved it out from Neovim to the backend.
It was easier to setup completion details for individual items that way, and now I only rely on a single `"Complete"`lua message that I pipe directly back to `cmp`:

```lua
function source:complete(params, callback)
  server.call({
    id = "Complete",
    path = vim.fn.expand("%:p"),
  }, function(reply)
    -- Items is a list where items have `label`,
    -- `insertText`, `filterText`, and `kind`,
    -- like we manually coded before.
    callback(reply.completion_items)
  end)
```

Either way works, I'll keep the description in Lua for illustrative purposes.
Check out the [Rust source code][] for more details.
:::

## Custom sorting

```lua
local function blog_compare(entry1, entry2)
  -- TODO
end

cmp.setup({
  sorting = {
    priority_weight = 2,
    comparators = {
      -- With cmp you chain comparators.
      cmp.config.compare.offset,
      cmp.config.compare.exact,
      cmp.config.compare.score,
      cmp.config.compare.recently_used,
      cmp.config.compare.locality,
      -- I added my comparator here.
      blog_compare,
      cmp.config.compare.kind,
      cmp.config.compare.sort_text,
      cmp.config.compare.length,
      cmp.config.compare.order,
    },
  },
})
```

```lua
local function blog_compare(entry1, entry2)
  -- Only sort blog entries.
  if entry1.source.name ~= "blog" or entry2.source.name ~= "blog" then
    return nil
  end

  local info1 = entry1.completion_item.info
  local info2 = entry2.completion_item.info

  if info1.type == "Img" then
    -- Sort images by modification time.
    if info1.modified > info2.modified then
      return true
    else
      return false
    end
  end

  return nil
end
```

## The result

![Complete tags in the frontmatter.](/images/extend_blog/complete_tags.png)

![Complete header references for a url. (The documentation preview jumped to the left).](/images/extend_blog/complete_header_ref_post.png)

# A word on indexing

> Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based
rows and columns).
> ^ `:help diagnostic-structure`

> Gets the (1,0)-indexed, buffer-relative cursor position for a given window
> (different windows showing the same buffer have independent cursor
> positions).
> ^ `:help nvim_win_get_cursor()`

> Most of the API uses 0-based indices, and ranges are end-exclusive. For the
end of a range, -1 denotes the last line/column.
>
> Exception: the following API functions use "mark-like" indexing (1-based
lines, 0-based columns):
>
> `nvim_get_mark()`\
> `nvim_buf_get_mark()`\
> `nvim_buf_set_mark()`\
> `nvim_win_get_cursor()`\
> `nvim_win_set_cursor()`
> ^ `:help api-indexing`

# Goto definition

```lua
local pos = vim.api.nvim_win_get_cursor(0)

server.call({
  id = "GotoDef",
  linenum = pos[1] - 1, -- Remember, (1,0)-indexing
  column = pos[2],
  path = vim.fn.expand("%:p"),
}, function(reply)
  vim.api.nvim_win_set_cursor(0, { reply.linenum + 1, reply.column })
end)
```

Can also jump to points

```lua
if reply.path then
  vim.cmd(":e" .. reply.path)
end

if reply.linenum then
  vim.api.nvim_win_set_cursor(0, { reply.linenum, reply.column })
end
```

But these doesn't register the cursor with the jumplist (`:help jumplist`), so you can't jump backwards/forwards with `<C-o>`/`<C-i>`.
We can fix that by marking the `'` register first:

```lua
if reply.path or reply.linenum then
  vim.cmd(":normal m'")
end
```

# Diagnostics

```lua
M.list_buffers = function()
  return vim.tbl_filter(function(buf)
    return vim.api.nvim_buf_is_valid(buf) and vim.api.nvim_buf_get_option(buf, "buflisted")
  end, vim.api.nvim_list_bufs())
end
```

> 1. Create a namespace `nvim_create_namespace()`. Note that the namespace must
>    have a name. Anonymous namespaces WILL NOT WORK.
> 2. (Optional) Configure options for the diagnostic namespace\
>    `vim.diagnostic.config()`.
> 3. Generate diagnostics.
> 4. Set the diagnostics for the buffer `vim.diagnostic.set()`.
> 5. Repeat from step 3.
> ^ `:help diagnostic-quickstart`

```lua
local buf = 0 -- Current buffer
local diagnostics = {
  {
    col = 2,
    end_col = 17,
    lnum = 30,
    end_lnum = 30,
    message = "Link to non-existent link definition: `tag`",
    severity = vim.diagnostic.severity.WARN,
  },
}

vim.diagnostic.set(vim.api.nvim_create_namespace("blog"), buf, diagnostics)
```

```lua
{
  ["/path/to/file.dj"] = {
    {
      col = 2,
      end_col = 17,
      lnum = 30,
      end_lnum = 30,
      message = "Link to non-existent link definition: `tag`",
      severity = vim.diagnostic.severity.WARN,
    },
  },
}
```

```lua
M.add_diagnostics = function(msg)
  for _, buf in ipairs(util.list_buffers()) do
    local buf_name = vim.api.nvim_buf_get_name(0)
    local buf_diagnostics = msg[buf_name]

    if buf_diagnostics then
      vim.diagnostic.set(vim.api.nvim_create_namespace("blog"), buf, buf_diagnostics)
    end
  end
end
```

# Connection status with lualine

# Terminal process

![](/images/extend_blog/blog_term.png)

# Browser preview

## Websocket communication

## Scrolling

[nvim-cmp]: https://github.com/hrsh7th/nvim-cmp
[telescope.nvim]: https://github.com/nvim-telescope/telescope.nvim
[configuration rabbit hole]: /blog/2023/10/01/rewriting_my_neovim_config_in_lua
[Developing a Neovim Docker Plugin from Scratch]: https://www.youtube.com/watch?v=HXABdG3xJW4
[Neovim config]: /blog/2023/10/01/rewriting_my_neovim_config_in_lua
[nvim-nio]: https://github.com/nvim-neotest/nvim-nio
[ripgrep]: https://github.com/BurntSushi/ripgrep
[blog_code]: https://github.com/treeman/jonashietala
[hotwatch]: https://github.com/francesca64/hotwatch
[axum]: https://github.com/tokio-rs/axum
[flume]: https://github.com/zesterer/flume
[tokio]: https://tokio.rs/
[plenary.nvim]: https://github.com/nvim-lua/plenary.nvim
[djot-tree-sitter]: https://github.com/treeman/tree-sitter-djot
[a Tree-sitter grammar]: /blog/2024/03/19/lets_create_a_tree-sitter_grammar
